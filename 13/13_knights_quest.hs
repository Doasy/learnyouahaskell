import Control.Monad

type KnightPos = (Int,Int)

moveKnight :: KnightPos -> [KnightPos]
moveKnight (c,r) = do
    (c',r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
               ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
               ]
    guard (c' `elem` [1..8] && r' `elem` [1..8])
    return (c',r')
-- moveKnight (4,4)
-- [(6,3),(6,5),(2,3),(2,5),(5,2),(5,6),(3,2),(3,6)]
-- moveKnight (6,3)
-- [(8,2),(8,4),(4,2),(4,4),(7,1),(7,5),(5,1),(5,5)]

moveKnight' :: KnightPos -> [KnightPos]
moveKnight' (c,r) = filter onBoard
    [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
    ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
    ]
    where onBoard (c,r) = c `elem` [1..8] && r `elem` [1..8]

in3 :: KnightPos -> [KnightPos]
in3 start = do
    first  <- moveKnight start
    second <- moveKnight first
    moveKnight second
-- in3 (6,2)
-- [(8,1),(8,3),(4,1),(4,3),(7,4),(5,4),(5,2),(5,4),(8,1),(8,5),(6,1),(6,5)
-- ,(8,1),(8,3),(4,1),(4,3),(7,4),(5,4),(8,3),(8,5),(4,3),(4,5),(7,2),(7,6)
-- ,(5,2),(5,6),(5,2),(8,3),(6,3),(5,4),(5,6),(8,3),(8,7),(6,3),(6,7),(8,1)
-- ,(8,3),(4,1),(4,3),(7,4),(5,4),(4,1),(4,3),(3,4),(1,4),(7,2),(7,4),(3,2)
-- ,(3,4),(6,1),(6,5),(4,1),(4,5),(5,2),(5,4),(1,2),(1,4),(4,1),(4,5),(2,1)
-- ,(2,5),(8,1),(8,3),(4,1),(4,3),(7,4),(5,4),(8,3),(8,5),(4,3),(4,5),(7,2)
-- ,(7,6),(5,2),(5,6),(4,1),(4,3),(3,4),(1,4),(4,3),(4,5),(3,2),(3,6),(1,2)
-- ,(1,6),(7,2),(3,2),(6,3),(4,3),(7,4),(7,6),(3,4),(3,6),(6,3),(6,7),(4,3)
-- ,(4,7),(5,2),(1,2),(4,3),(2,3),(5,4),(5,6),(1,4),(1,6),(4,3),(4,7),(2,3)
-- ,(2,7),(7,2),(7,4),(3,2),(3,4),(6,1),(6,5),(4,1),(4,5),(7,4),(7,6),(3,4)
-- ,(3,6),(6,3),(6,7),(4,3),(4,7),(6,1),(6,3),(7,4),(6,5),(6,7),(7,4),(7,8)
-- ,(8,1),(8,3),(4,1),(4,3),(7,4),(5,4),(8,5),(8,7),(4,5),(4,7),(7,4),(7,8)
-- ,(5,4),(5,8),(5,2),(5,4),(8,1),(8,5),(6,1),(6,5),(5,4),(5,6),(8,3),(8,7)
-- ,(6,3),(6,7),(5,2),(5,4),(1,2),(1,4),(4,1),(4,5),(2,1),(2,5),(5,4),(5,6)
-- ,(1,4),(1,6),(4,3),(4,7),(2,3),(2,7),(8,1),(8,3),(4,1),(4,3),(7,4),(5,4)
-- ,(8,5),(8,7),(4,5),(4,7),(7,4),(7,8),(5,4),(5,8),(6,1),(6,3),(2,1),(2,3)
-- ,(5,4),(3,4),(6,5),(6,7),(2,5),(2,7),(5,4),(5,8),(3,4),(3,8)]

-- without do notation (I prefer this):
in3' :: KnightPos -> [KnightPos]
in3' start = moveKnight start >>= moveKnight >>= moveKnight
-- the book does return start >>= moveKnight ... But it's not necessary.

canReachIn3 :: KnightPos -> KnightPos -> Bool
canReachIn3 start end = end `elem` in3 start

canReachIn3 (6,2) (6,1)
-- True
canReachIn3 (6,2) (7,3)
-- False

-- Task: change these functions so that if you can reach a position in 3
-- moves, it lists those moves. (Use a Writer?)
